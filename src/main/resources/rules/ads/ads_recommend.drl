package rules.ads

import model.Place
import model.Post

global repo.UserRepository  userRepo
global repo.PostRepository  postRepo
global repo.PlaceRepository placeRepo
global repo.RatingRepository ratingRepo
global java.time.LocalDateTime NOW

// i dalje deklarisani da setGlobal ne puca, iako ih upit ne koristi
global String ADS_USER_ID
global String ADS_CITY
global String ADS_TYPE_KW
global String ADS_TOPIC_TAG

dialect "java"

// ---------- Helpers ----------
function String lc(String s) { return s == null ? "" : s.toLowerCase(); }

function boolean containsTagIC(java.util.Collection tags, String tag) {
    if (tags == null || tag == null) return false;
    String needle = lc(tag);
    for (Object o : tags) {
        if (o != null && lc(o.toString()).equals(needle)) return true;
    }
    return false;
}

function boolean anyTagContainsIC(java.util.Collection tags, String sub) {
    if (tags == null || sub == null) return false;
    String needle = lc(sub);
    for (Object o : tags) {
        if (o != null && lc(o.toString()).contains(needle)) return true;
    }
    return false;
}

// ---------- Query-je koje koristimo u kompoziciji ----------
query "UserLikedEnoughForTag"( String $userId, String $topicTag )
    Number( $cnt : intValue ) from accumulate(
        Post( $pid : id, eval( containsTagIC(hashtags, $topicTag) ) ),
        init( int c = 0; ),
        action( if ( postRepo.hasUserLiked($pid, $userId) ) { c++; } ),
        result( c )
    )
    eval( $cnt > 3 )
end

query "UserAuthoredUsedTag"( String $userId, String $topicTag )
    Number( $cnt : intValue ) from accumulate(
        Post( authorId == $userId, eval( containsTagIC(hashtags, $topicTag) ) ),
        count(1)
    )
    eval( $cnt > 0 )
end

query "UserHasPositiveType"( String $userId, String $typeKw )
    eval( ratingRepo.userHasPositiveRatingForType($userId, "#" + lc($typeKw)) )
end

query "NotAlreadyRated"( String $userId, Place $p )
    eval( !ratingRepo.existsByUserAndPlace($userId, $p.getId()) )
end

// ---------- Glavni upit: čist backward-chaining, bez pravila ----------
query "Ads:ForTypeAndTag"( String $userId, String $city, String $typeKw, String $topicTag )
    $p : Place(
        // type match: opis sadrži typeKw ILI hešteg "#typeKw"
        ( eval( lc(description).contains(lc($typeKw)) )
          || eval( containsTagIC(hashtags, "#" + $typeKw) ) ),
        // tematski tag
        eval( containsTagIC(hashtags, $topicTag) ),
        // grad
        eval( lc(city).equals(lc($city)) )
    )
    // ugnježdene provere
    UserLikedEnoughForTag( $userId, $topicTag; )
    UserAuthoredUsedTag(  $userId, $topicTag; )
    UserHasPositiveType(  $userId, $typeKw;   )
    NotAlreadyRated(      $userId, $p;        )

    // objasni-zašto kao izlazna promenljiva
    $why : String() from (
        "preporuka: voli " + $typeKw +
        ", " + $topicTag + " > 3 lajka, koristio " + $topicTag +
        ", pozitivan utisak o " + $typeKw + ", grad: " + $city
    )
end
